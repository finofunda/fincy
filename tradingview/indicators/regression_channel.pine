// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Copywright © 2026 ZenithClown (Debmalya Pramanik) | https://zenithclown.github.io/ | https://www.linkedin.com/in/dpramanik/
//
//@version=6
//
// ==================================================================
// OBJECTTIVE: Create a Regression Channel & Forward Forecast
//
// A regression channel (linear, exponential, etc.) can potentially
// show the movement of the market over a period of time. Typically
// an instrument move in a direction thus a linear regression can be
// useful to predict the potential flow, while exponential channel can
// be useful for a crypto currency like asset.
//
// Check https://github.com/finofunda/fincy for additional details.
// Check https://in.tradingview.com/u/ZenithClown/ for TV Profile.
// ==================================================================

indicator('Regression Channel', overlay = true)

// ------------------------------------------------------------------
// INPUT(s) for Regression Channel Calculation(s)
// ------------------------------------------------------------------

regressionType = input.string(
    'linear', 'Regression Type'
    , options = [
        'linear', 'exponential'
    ]
)

dataSource = input.source(close, 'Data Source')

// Lookback and Forecast Period Settings

lookbackPeriod = input.int(
    100, 'Lookback Period (No. of Candels)', minval = 2, step = 1
    , group = 'Model Settings'
    , tooltip = 'Setting a value >= 5000 may result in a slow performance.'
)

// Channel Settings, allow dynamic upper and lower channel controls

showUpperChannel = input.bool(
    true, 'Show Upper Deviation Channel'
    , group = 'Channel Settings', inline = 'Upper Channel'
)

upperChannelDeviation = input.float(
    2.0, '', active = showUpperChannel, step = 0.1
    , group = 'Channel Settings', inline = 'Upper Channel'
)

showLowerChannel = input.bool(
    true, 'Show Lower Deviation Channel'
    , group = 'Channel Settings', inline = 'Lower Channel'
)

lowerChannelDeviation = input.float(
    2.0, '', active = showLowerChannel, step = 0.1
    , group = 'Channel Settings', inline = 'Lower Channel'
)

nTopBottom = input.int(
    2, 'No. of Channel(s) from Mean Line', minval = 1, maxval = 4, step = 1
    , tooltip = 'Create multiple channels to understand market range.'
    , group = 'Channel Settings'
)

// ------------------------------------------------------------------
// Display Setting(s) for Forecast Period & Color(s)
//
// Display settings are defined of two types - general settings which
// are applicable for all (ex. color settings) and regression model
// specific settings. Check the group names for more details.
// ------------------------------------------------------------------

isLinearModel = regressionType == 'linear' ? true : false
isExponentialModel = regressionType == 'exponential' ? true : false

// Inputs for Linear Regression Model

showPearsonInput = input.bool(
    false, 'Show Pearsons R', active = isLinearModel
    , group = 'Display Settings (Linear Model)'
)

// Settings for Performance Table

showPerformanceTable = input.bool(
    true, 'Performance Table'
    , group = 'Display Settings'
    , inline = 'Performance Table'
    , tooltip = 'Display performance metrics and model fit quality.'
)

tablePosition = input.string(
    'Bottom Right', '', active = showPerformanceTable
    , options = [
        'Top Left', 'Top Center', 'Top Right',
        'Middle Left', 'Middle Center', 'Middle Right',
        'Bottom Left', 'Bottom Center', 'Bottom Right'
    ]
    , group = 'Display Settings'
    , inline = 'Performance Table'
)

// General Display - Line Extensions

extendLeftInput = input.bool(
    false, 'Extend Lines towards Left'
    , group = 'Display Settings'
)

extendRightInput = input.bool(
    true, 'Extend Lines towards Right'
    , group = 'Display Settings'
)

useColorGradient = input.bool(
    true, 'Show Color Gradient'
    , group = 'Display Settings'
)

colorUpperChannel = input.color(
    color.new(color.green, 85), ''
    , group = 'Display Settings', inline = 'Display Settings'
)

colorLowerChannel = input.color(
    color.new(color.red, 85), ''
    , group = 'Display Settings', inline = 'Display Settings'
)

// ------------------------------------------------------------------
// Function(s)/Calculation(s) for Linear Regression & Deviation
//
// linearRegression - Function to calculate linear regression values,
// namely the slope and intercept. The function uses `barstate.islast`
// to prevent the model to recalculate on every candel (thus reducing
// unnecessary load time) and calculates only when we've reached the
// end of the loop.
// ------------------------------------------------------------------

linearRegression(source, length) =>
    if not barstate.islast
        [float(na), float(na), float(na)]
    else
        sumX = 0.0
        sumY = 0.0
        sumXY = 0.0
        sumXSqr = 0.0

        for i = 0 to length - 1 by 1
            value = source[i]
            perct = i + 1.0

            sumX += perct
            sumY += value
            sumXY += perct * value
            sumXSqr += math.pow(perct, 2)

        slope = (length * sumXY - sumX * sumY) / (length * sumXSqr - math.pow(sumX, 2))

        average = sumY / length
        intercept = average - slope * sumX / length + slope

        [slope, average, intercept]

linearDeviation(source, length, slope, average, intercept) =>
    upperDeviation = 0.0
    lowerDeviation = 0.0

    standardDeviationAccum = 0.0

    dsxx = 0.0
    dsyy = 0.0
    dsxy = 0.0

    periods = length - 1
    daY = intercept + slope * periods / 2

    interceptCopy = intercept
    
    sumSquaredError = 0.0
    sumPercentageError = 0.0
    sumActual = 0.0
    sumPredicted = 0.0

    for i = 0 to periods by 1
        price = high[i] - interceptCopy

        if price > upperDeviation
            upperDeviation := price

        price := interceptCopy - low[i]

        if price > lowerDeviation
            lowerDeviation := price

        price := source[i]
        
        predicted = interceptCopy
        actual = source[i]
        error = actual - predicted
        
        sumSquaredError += math.pow(error, 2)
        if actual != 0
            sumPercentageError += math.abs(error / actual)
        sumActual += actual
        sumPredicted += predicted
        
        price -= interceptCopy
        
        interceptCopy += slope
    
    avgActual = sumActual / length
    avgPredicted = sumPredicted / length
    
    interceptCopy := intercept
    
    for i = 0 to periods by 1
        actual = source[i]
        predicted = interceptCopy
        
        dxt = actual - avgActual
        dyt = predicted - avgPredicted
        
        dsxx += math.pow(dxt, 2)
        dsyy += math.pow(dyt, 2)
        dsxy += dxt * dyt
        
        interceptCopy += slope
        
    pearsonsR = dsxx == 0 or dsyy == 0 ? 0 : dsxy / math.sqrt(dsxx * dsyy)
    standardDeviation = ta.stdev(source, length)
    
    rmse = math.sqrt(sumSquaredError / length)
    rmpe = (sumPercentageError / length) * 100
    rSquared = math.pow(pearsonsR, 2)
    mae = sumSquaredError / length
    mape = rmpe
    
    [standardDeviation, pearsonsR, upperDeviation, lowerDeviation, rmse, rmpe, rSquared, mae, mape]

// ------------------------------------------------------------------
// Function(s)/Calculation(s) for Exponential Regression & Deviation
//
// exponentialRegression - Function to calculate exponential
// regression values, which can be used to form a baseline. An
// exponential regression line maybe useful in certain instruments
// like the crypto currencies/forex where volatility is much higher.
// ------------------------------------------------------------------

exponentialRegression(source, length) =>
    if not barstate.islast
        [float(na), float(na), float(na)]
    else
        sumX = 0.0
        sumY = 0.0
        sumXY = 0.0
        sumXSqr = 0.0

        for i = 0 to length - 1 by 1
            value = source[i]
            
            if value > 0
                perct = i + 1.0
                logValue = math.log(value)
                
                sumX += perct
                sumY += logValue
                sumXY += perct * logValue
                sumXSqr += math.pow(perct, 2)

        slope = (length * sumXY - sumX * sumY) / (length * sumXSqr - math.pow(sumX, 2))
        
        average = sumY / length
        intercept = average - slope * sumX / length + slope
        
        [slope, average, intercept]

exponentialDeviation(source, length, slope, average, intercept) =>
    upperDeviation = 0.0
    lowerDeviation = 0.0
    
    standardDeviationAccum = 0.0
    
    periods = length - 1
    
    sumSquaredError = 0.0
    sumPercentageError = 0.0
    sumActual = 0.0
    dsxx = 0.0
    dsyy = 0.0
    dsxy = 0.0
    
    for i = 0 to periods by 1
        expValue = math.exp(intercept + slope * (periods - i))
        
        price = high[i] - expValue
        
        if price > upperDeviation
            upperDeviation := price
        
        price := expValue - low[i]
        
        if price > lowerDeviation
            lowerDeviation := price
        
        if source[i] > 0
            residual = math.log(source[i]) - (intercept + slope * (periods - i))
            standardDeviationAccum += math.pow(residual, 2)
            
            actual = source[i]
            predicted = expValue
            error = actual - predicted
            
            sumSquaredError += math.pow(error, 2)
            if actual != 0
                sumPercentageError += math.abs(error / actual)
            sumActual += actual
            
            dxt = actual - (sumActual / (i + 1))
            dyt = predicted - expValue
            dsxx += math.pow(dxt, 2)
            dsyy += math.pow(dyt, 2)
            dsxy += dxt * dyt
    
    standardDeviation = math.sqrt(standardDeviationAccum / length)
    
    rmse = math.sqrt(sumSquaredError / length)
    rmpe = (sumPercentageError / length) * 100
    pearsonsR = dsxx == 0 or dsyy == 0 ? 0 : dsxy / math.sqrt(dsxx * dsyy)
    rSquared = math.pow(pearsonsR, 2)
    mae = sumSquaredError / length
    mape = rmpe
    
    [standardDeviation, upperDeviation, lowerDeviation, rmse, rmpe, rSquared, pearsonsR, mae, mape]

// ------------------------------------------------------------------
// Visualization of Regression, Forecast & Top/Bottom Bounds
// ------------------------------------------------------------------

extendLineType = switch
    extendLeftInput and extendRightInput => extend.both
    extendLeftInput => extend.left
    extendRightInput => extend.right
    => extend.none

performanceTablePosition = switch tablePosition
    'Top Left' => position.top_left
    'Top Center' => position.top_center
    'Top Right' => position.top_right
    'Middle Left' => position.middle_left
    'Middle Center' => position.middle_center
    'Middle Right' => position.middle_right
    'Bottom Left' => position.bottom_left
    'Bottom Center' => position.bottom_center
    => position.bottom_right

// ? Helper function(s) to draw objects into screen

createUpdateLine(existingLine, x1, y1, x2, y2, lineColor) =>
    if na(existingLine) and not na(y1)
        line.new(
            x1, y1, x2, y2
            , width = 1
            , extend = extendLineType
            , color = lineColor
        )
    else
        line.set_xy1(existingLine, x1, y1)
        line.set_xy2(existingLine, x2, y2)
        existingLine

createChannelLine(channelArray, index, x1, y1, x2, y2, lineColor) =>
    if na(array.get(channelArray, index)) and not na(y1)
        array.set(
            channelArray, index
            , line.new(
                x1, y1, x2, y2
                , width = 1
                , extend = extendLineType
                , color = color.new(lineColor, 0)
            )
        )

createUpdateFill(
    fillArray, index, baseLine, channelLine, fillColor, transparency
) =>
    if not na(channelLine) and not na(baseLine)
        if na(array.get(fillArray, index))
            array.set(fillArray, index, linefill.new(baseLine, channelLine, color.new(fillColor, transparency)))
        else
            linefill.set_color(array.get(fillArray, index), color.new(fillColor, transparency))

// ? Assess model fit's quality for qualititave assessment

assessFitQuality(rSquared) =>
    fitQuality = 'Poor Fit'
    textBgColor = color.new(color.red, 85)

    if rSquared > 0.8
        fitQuality := 'Excellent Fit'
        textBgColor := color.new(color.green, 65)
    else if rSquared > 0.6
        fitQuality := 'Good Fit'
        textBgColor := color.new(color.green, 85)
    else if rSquared > 0.4
        fitQuality := 'Moderate Fit'
        textBgColor := color.new(color.yellow, 85)
    
    [fitQuality, textBgColor]

assessModelCorrelation(pearsonsR) =>
    correlation = ''
    textBgColor = color.new(color.red, 30)

    if na(pearsonsR)
        correlation := '# N/A'
    else if math.abs(pearsonsR) > 0.9
        correlation := 'Very Strong'
        textBgColor := color.new(color.green, 65)
    else if math.abs(pearsonsR) > 0.7
        correlation := 'Strong'
        textBgColor := color.new(color.green, 85)
    else if math.abs(pearsonsR) > 0.5
        correlation := 'Moderate'
        textBgColor := color.new(color.yellow, 85)
    else if math.abs(pearsonsR) > 0.3
        correlation := 'Weak'
        textBgColor := color.new(color.red, 85)
    else
        correlation := 'Very Weak'
        textBgColor := color.new(color.red, 65)
    
    correlation += ' Correlation'
    // calculate the correlation direction also
    direction = pearsonsR > 0 ? 'POSITIVE' : pearsonsR < 0 ? 'NEGATIVE' : 'NO'

    [correlation, textBgColor, direction]

// ? Function to draw performance table

drawPerformanceTable(rSquared, pearsonsR, rmse, rmpe, mape) =>
    [fitQuality, fitQualityColor] = assessFitQuality(rSquared)
    [correlation, correlationColor, correlationDirection] = assessModelCorrelation(pearsonsR)

    tbTxtSize = size.small
    tbTxtHCol = color.white
    tbTxtNCol = color.black

    tbHCBgol = color.new(color.blue, 0)
    tbRBgCol = color.new(color.gray, 90)

    var table performanceTable = table.new(performanceTablePosition, 2, 8, border_width = 1)

    table.cell(
        performanceTable, 0, 0, 'Per. Metric'
        , text_color = tbTxtHCol, bgcolor = tbHCBgol, text_size = tbTxtSize
    )
    table.cell(
        performanceTable, 1, 0, 'Metric Value'
        , text_color = tbTxtHCol, bgcolor = tbHCBgol, text_size = tbTxtSize
    )

    table.cell(
        performanceTable, 0, 1, 'RMSE'
        , text_color = tbTxtNCol, bgcolor = tbRBgCol, text_size = tbTxtSize
    )
    table.cell(
        performanceTable, 1, 1, str.tostring(rmse, '#.###')
        , text_color = tbTxtNCol, bgcolor = tbRBgCol, text_size = tbTxtSize
    )

    table.cell(
        performanceTable, 0, 2, 'RMPE (%)'
        , text_color = tbTxtNCol, bgcolor = tbRBgCol, text_size = tbTxtSize
    )
    table.cell(
        performanceTable, 1, 2, str.tostring(rmpe, '#.###')
        , text_color = tbTxtNCol, bgcolor = tbRBgCol, text_size = tbTxtSize
    )

    table.cell(
        performanceTable, 0, 3, 'R²'
        , text_color = tbTxtNCol, bgcolor = tbRBgCol, text_size = tbTxtSize
    )
    table.cell(
        performanceTable, 1, 3, str.tostring(rSquared, '#.###')
        , text_color = tbTxtNCol, bgcolor = tbRBgCol, text_size = tbTxtSize
    )

    table.cell(
        performanceTable, 0, 4, 'MAPE (%)'
        , text_color = tbTxtNCol, bgcolor = tbRBgCol, text_size = tbTxtSize
    )
    table.cell(
        performanceTable, 1, 4, str.tostring(mape, '#.###')
        , text_color = tbTxtNCol, bgcolor = tbRBgCol, text_size = tbTxtSize
    )

    table.cell(
        performanceTable, 0, 5, 'Fit Quality'
        , text_color = tbTxtHCol, bgcolor = tbTxtNCol, text_size = tbTxtSize
    )
    table.cell(
        performanceTable, 1, 5, fitQuality
        , text_color = tbTxtNCol, bgcolor = fitQualityColor, text_size = tbTxtSize
    )

    table.cell(
        performanceTable, 0, 6, 'Model Correlation'
        , text_color = tbTxtHCol, bgcolor = tbTxtNCol, text_size = tbTxtSize
    )
    table.cell(
        performanceTable, 1, 6, correlation + ' (' + correlationDirection + ')'
        , text_color = tbTxtNCol, bgcolor = correlationColor, text_size = tbTxtSize
    )

// ? Draw On Graph - Based on Regression Type

switch regressionType
    'linear' =>
        [slope, average, intercept] = linearRegression(dataSource, lookbackPeriod)

        startPriceLinReg = intercept + slope * (lookbackPeriod - 1)
        endPriceLinReg = intercept

        var line meanLineLinReg = na
        meanLineLinReg := createUpdateLine(
            meanLineLinReg
            , bar_index - lookbackPeriod + 1, startPriceLinReg, bar_index, endPriceLinReg
            , color.new(color.black, 0)
        )

        [standardDeviation, pearsonsR, upperDeviation, lowerDeviation, rmse, rmpe, rSquared, mae, mape] = linearDeviation(
            dataSource, lookbackPeriod, slope, average, intercept
        )

        var array<line> upperChannels = array.new<line>(nTopBottom)
        var array<line> lowerChannels = array.new<line>(nTopBottom)
        var array<linefill> upperFills = array.new<linefill>(nTopBottom)
        var array<linefill> lowerFills = array.new<linefill>(nTopBottom)

        for i = 0 to nTopBottom - 1 by 1
            upperMultiplier = (i + 1) * (showUpperChannel ? upperChannelDeviation : 1.0) / nTopBottom
            lowerMultiplier = (i + 1) * (showLowerChannel ? lowerChannelDeviation : 1.0) / nTopBottom

            upperStartPrice = startPriceLinReg + upperMultiplier * standardDeviation
            upperEndPrice = endPriceLinReg + upperMultiplier * standardDeviation

            lowerStartPrice = startPriceLinReg - lowerMultiplier * standardDeviation
            lowerEndPrice = endPriceLinReg - lowerMultiplier * standardDeviation

            createChannelLine(
                upperChannels, i
                , bar_index - lookbackPeriod + 1, upperStartPrice, bar_index, upperEndPrice
                , colorUpperChannel
            )
            
            if useColorGradient
                gradientTransparency = int(85 + (100 - 85) * (i + 1) / nTopBottom)
                baseLine = i == 0 ? meanLineLinReg : array.get(upperChannels, i - 1)
                createUpdateFill(
                    upperFills, i
                    , baseLine, array.get(upperChannels, i)
                    , colorUpperChannel, gradientTransparency
                )

            createChannelLine(
                lowerChannels, i
                , bar_index - lookbackPeriod + 1, lowerStartPrice, bar_index, lowerEndPrice
                , colorLowerChannel
            )
            
            if useColorGradient
                gradientTransparency = int(85 + (100 - 85) * (i + 1) / nTopBottom)
                baseLine = i == 0 ? meanLineLinReg : array.get(lowerChannels, i - 1)
                createUpdateFill(
                    lowerFills, i
                    , baseLine, array.get(lowerChannels, i)
                    , colorLowerChannel, gradientTransparency
                )

        var label r = na
        label.delete(r[1])

        if showPearsonInput and not na(pearsonsR)
            r := label.new(
                bar_index - lookbackPeriod + 1, startPriceLinReg
                , str.tostring(pearsonsR, 'R = #.#####')
                , color = color.new(color.white, 100)
                , textcolor = color.new(color.black, 0)
                , size = size.normal, style = label.style_label_up
            )
        
        if showPerformanceTable and not na(rmse)
            drawPerformanceTable(rSquared, pearsonsR, rmse, rmpe, mape)

    'exponential' =>
        [slope, average, intercept] = exponentialRegression(dataSource, lookbackPeriod)

        startPriceExpReg = math.exp(intercept + slope * (lookbackPeriod - 1))
        endPriceExpReg = math.exp(intercept)

        var line meanLineExpReg = na
        meanLineExpReg := createUpdateLine(
            meanLineExpReg
            , bar_index - lookbackPeriod + 1, startPriceExpReg, bar_index, endPriceExpReg
            , color.new(color.black, 0)
        )

        [standardDeviation, upperDeviation, lowerDeviation, rmse, rmpe, rSquared, pearsonsR, mae, mape] = exponentialDeviation(
            dataSource, lookbackPeriod, slope, average, intercept
        )

        var array<line> upperChannelsExp = array.new<line>(nTopBottom)
        var array<line> lowerChannelsExp = array.new<line>(nTopBottom)
        var array<linefill> upperFillsExp = array.new<linefill>(nTopBottom)
        var array<linefill> lowerFillsExp = array.new<linefill>(nTopBottom)

        for i = 0 to nTopBottom - 1 by 1
            upperMultiplier = (i + 1) * (showUpperChannel ? upperChannelDeviation : 1.0) / nTopBottom
            lowerMultiplier = (i + 1) * (showLowerChannel ? lowerChannelDeviation : 1.0) / nTopBottom

            upperStartPrice = math.exp(intercept + slope * (lookbackPeriod - 1) + upperMultiplier * standardDeviation)
            upperEndPrice = math.exp(intercept + upperMultiplier * standardDeviation)

            lowerStartPrice = math.exp(intercept + slope * (lookbackPeriod - 1) - lowerMultiplier * standardDeviation)
            lowerEndPrice = math.exp(intercept - lowerMultiplier * standardDeviation)

            createChannelLine(
                upperChannelsExp, i
                , bar_index - lookbackPeriod + 1, upperStartPrice, bar_index, upperEndPrice
                , colorUpperChannel
            )

            if useColorGradient
                gradientTransparency = int(85 + (100 - 85) * (i + 1) / nTopBottom)
                baseLine = i == 0 ? meanLineExpReg : array.get(upperChannelsExp, i - 1)
                createUpdateFill(
                    upperFillsExp, i
                    , baseLine, array.get(upperChannelsExp, i)
                    , colorUpperChannel, gradientTransparency
                )

            createChannelLine(
                lowerChannelsExp, i
                , bar_index - lookbackPeriod + 1, lowerStartPrice, bar_index, lowerEndPrice
                , colorLowerChannel
            )

            if useColorGradient
                gradientTransparency = int(85 + (100 - 85) * (i + 1) / nTopBottom)
                baseLine = i == 0 ? meanLineExpReg : array.get(lowerChannelsExp, i - 1)
                createUpdateFill(
                    lowerFillsExp, i
                    , baseLine, array.get(lowerChannelsExp, i)
                    , colorLowerChannel, gradientTransparency
                )
        
        if showPerformanceTable and not na(rmse)
            drawPerformanceTable(rSquared, pearsonsR, rmse, rmpe, mape)

    => display.none
